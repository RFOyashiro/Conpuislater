#include <stdio.h>
#include <stdlib.h>

#include "analyseur_syntaxique.h"
#include "symboles.h"
#include "analyseur_lexical.h"
#include "premiers.h"
#include "suivants.h"

// Number of sapce per indentation level.
#define NB_SPACE_PER_INDENT 2
// Display debug values if is 1.
#define DEBUG 1

/**
 * Last value returned by lexical analyser.
 */
char currentUnit;
/**
 * Name of current token if needed to be displayed.
 */
char nomToken[100];
/**
 * Value of current token if needed to be displayed.
 */
char valeur[100];

/**
 * Current indentation level.
 */
int currentIndent;

/**
 * Indent depending of the current level of indentation.
 */
void DisplayIndent(void) {
	int i;
	for (i = 0; i < currentIndent; ++i) {
		printf(" ");
	}
}

/**
 * DEBUG
 * Display a XML open tag with indentation.
 * char * foncName Tag name
 */
void openXML(const char *tagName) {
	if (!DEBUG) return;
        DisplayIndent();
        printf("<%s>\n", tagName);
	currentIndent += NB_SPACE_PER_INDENT;
}

/**
 * DEBUG
 * Display a XML close tag with indentation.
 * char * foncName Tag name
 */
void closeXML(const char *tagName) {
	if (!DEBUG) return;
	currentIndent -= NB_SPACE_PER_INDENT;
	DisplayIndent();
	printf("</%s>\n", tagName);
}

/**
 * DEBUG
 * Get the tag corresponding to the token (terminal symbol only)
 */
char * getTokenTag(int token) {
	if (!DEBUG) return NULL;
	switch (token) {
		case ENTIER:
		case SI:
		case ALORS:
		case SINON:
		case TANTQUE:
		case FAIRE:
		case RETOUR:
		case LIRE:
		case ECRIRE:
			return "mot_clef";
		case POINT_VIRGULE:
		case PLUS:
		case MOINS:
		case FOIS:
		case DIVISE:
		case PARENTHESE_OUVRANTE:
		case PARENTHESE_FERMANTE:
		case CROCHET_OUVRANT:
		case CROCHET_FERMANT:
		case ACCOLADE_OUVRANTE:
		case ACCOLADE_FERMANTE:
		case EGAL:
		case INFERIEUR:
		case ET:
		case OU:
		case NON:
		case VIRGULE:
			return "symbole";
		case ID_VAR:
			return "id_variable";
		case ID_FCT:
			return "id_fonction";
		case NOMBRE :
			return "nombre";
	}
}

/**
 * DEBUG
 * Display the token value with indentation.
 */
void putToken(int token) {
	if (!DEBUG) return;
	nom_token(token, nomToken, valeur);
	DisplayIndent();
	char * tag = getTokenTag(token);
	printf("<%s>%s</%s>\n", tag, valeur, tag);
}

/**
 * check if current token correspond to the expected token and , if so, display it (only if DEBUG) and get next token.
 * int token expected token
 * return true if match found and next token token get, just false otherwise.
 */
int checkToken(int token) {
	if (token == currentUnit) {
		putToken(currentUnit);
		currentUnit = yylex();
		return 1;
	}
	return 0;
}

/**
 * Display "Error on token : " with the value of the currentUnit.
 */
void error() {
	nom_token(currentUnit, nomToken, valeur);
	fprintf(stderr, "Error on token : %s\n", valeur);
	exit (EXIT_FAILURE);
}



void pg (void) {
	openXML(__func__);
	if (est_premier(_optDecVariables_, currentUnit) || 
	  est_premier(_listeDecFonctions_, currentUnit) ||
	  est_suivant(_programme_, currentUnit)) {
                odv();
                ldf();
		closeXML(__func__);
		return;	
	}
	error();
	closeXML(__func__);
}

void odv (void) {
	openXML(__func__);
	if (est_premier(_listeDecVariables_, currentUnit)) {
                ldv();
		if (checkToken(POINT_VIRGULE)) {
			
			closeXML(__func__);
			return;
		}
	}
	if (est_suivant(_optDecVariables_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void ldv (void) {
	openXML(__func__);
	if (est_premier(_declarationVariable_, currentUnit)) {
                dv();
                ldvb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void ldvb (void) {
	openXML(__func__);
	if (checkToken(VIRGULE)) {
                dv();
                ldvb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_listeDecVariablesBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void dv (void) {
	openXML(__func__);
	if (checkToken(ENTIER)) {
		
		if (checkToken(ID_VAR)) {
			
                        ott();
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);
}

void ott (void) {
	openXML(__func__);
	if (checkToken(CROCHET_OUVRANT)) {
		
		if (checkToken(NOMBRE)) {
			
			if (checkToken(CROCHET_FERMANT)) {
				
				closeXML(__func__);
				return;
			}
		}
	}
	if (est_suivant(_optTailleTableau_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void ldf (void) {
	openXML(__func__);
	if (est_premier(_declarationFonction_, currentUnit)) {
                df();
                ldf();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_listeDecFonctions_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void df (void) {
	openXML(__func__);
	if (checkToken(ID_FCT)) {
		
                lp();
                odv();
                ib();
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}

void lp (void) {
	openXML(__func__);
	if (checkToken(PARENTHESE_OUVRANTE)) {
		
                oldv();
		if (checkToken(PARENTHESE_FERMANTE)) {
			
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);
}

void oldv (void) {
	openXML(__func__);
	if (est_premier(_listeDecVariables_, currentUnit)) {
                ldv();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_optListeDecVariables_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	closeXML(__func__);
	error();
}

void i (void) {
	openXML(__func__);
	if (est_premier(_instructionAffect_, currentUnit)) {
                iaff();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionBloc_, currentUnit)) {
                ib();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionSi_, currentUnit)) {
                isi();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionTantque_, currentUnit)) {
                itq();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionAppel_, currentUnit)) {
                iapp();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionRetour_, currentUnit)) {
                iret();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionEcriture_, currentUnit)) {
                iecr();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionVide_, currentUnit)) {
                ivide();
		closeXML(__func__);
		return;
	}
	if (est_premier(_instructionFaire_, currentUnit)) {
                ift();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void iaff (void) {
	openXML(__func__);
	if (est_premier(_var_, currentUnit)) {
                var();
		if (checkToken(EGAL)) {
			
                        exp();
			if (checkToken(POINT_VIRGULE)) {
				
				closeXML(__func__);
				return;
			}
		}
	}
	error();
	closeXML(__func__);
}

void ib (void) {
	openXML(__func__);
	if (checkToken(ACCOLADE_OUVRANTE)) {
		
                li();
		if (checkToken(ACCOLADE_FERMANTE)) {
			
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);
}

void li (void) {
	openXML(__func__);
	if (est_premier(_instruction_, currentUnit)) {
                i();
                li();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_listeInstructions_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void isi (void) {
	openXML(__func__);
	if (checkToken(SI)) {
		
                exp();
		if (checkToken(ALORS)) {
			
                        ib();
                        osinon();
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);	
}

void osinon (void) {
	openXML(__func__);
	if (checkToken(SINON)) {
		
                ib();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_optSinon_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void itq (void) {
	openXML(__func__);
	if (checkToken(TANTQUE)) {
		
                exp();
		if (checkToken(FAIRE)) {
			
                        ib();
			closeXML(__func__);
			return;
		}
	}
	
	error();
	closeXML(__func__);
}

void ift(void) {
	openXML(__func__);
	if (checkToken(FAIRE)){
		ib();
		if (checkToken(TANTQUE)) {
			exp();
			
			if (checkToken(POINT_VIRGULE)) {
				closeXML(__func__);
				return;
			}
		}	
	}
	error();
	closeXML(__func__);
}

void iapp (void) {
	openXML(__func__);
	if (est_premier(_appelFct_, currentUnit)) {
                appf();
		if (checkToken(POINT_VIRGULE)) {
			
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);
}

void iret (void) {
	openXML(__func__);
	if (checkToken(RETOUR)) {
		
                exp();
		if (checkToken(POINT_VIRGULE)) {
			
			closeXML(__func__);
			return;
		}
	}
	error();
	closeXML(__func__);
}

void iecr (void) {
	openXML(__func__);
	if (checkToken(ECRIRE)) {
		
		if (checkToken(PARENTHESE_OUVRANTE)) {
			
                        exp();
			if (checkToken(PARENTHESE_FERMANTE)) {
				
				if (checkToken(POINT_VIRGULE)) {
					
					closeXML(__func__);
					return;
				}
			}
		}
	}
	error();
	closeXML(__func__);
}

void ivide (void) {
	openXML(__func__);
	if (checkToken(POINT_VIRGULE)) {
		
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void exp (void) {
	openXML(__func__);
	if (est_premier(_conjonction_, currentUnit)) {
                conj();
                expb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void expb (void) {
	openXML(__func__);
	if (checkToken(OU)) {
		
                conj();
                expb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_expressionBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void conj (void) {
	openXML(__func__);
	if (est_premier(_comparaison_, currentUnit)) {
                comp();
                conjb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void conjb (void) {
	openXML(__func__);
	if (checkToken(ET)) {
		
                comp();
                conjb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_conjonctionBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void comp (void) {
	openXML(__func__);
	if (est_premier(_expArith_, currentUnit)) {
                e();
                compb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void compb (void) {
	openXML(__func__);
	if (checkToken(EGAL)) {
		
                e();
                compb();
		closeXML(__func__);
		return;
	}
	if (checkToken(INFERIEUR)) {
		
                e();
                compb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_comparaisonBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	
	error();	
	closeXML(__func__);
}

void e (void) {
	openXML(__func__);
	if (est_premier(_terme_, currentUnit)) {
                t();
                eb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void eb (void) {
	openXML(__func__);
	if (checkToken(PLUS)) {
		
                t();
                eb();
		closeXML(__func__);
		return;
	}
	if (checkToken(MOINS)) {
		
                t();
                eb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_expArithBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void t (void) {
	openXML(__func__);
	if (est_premier(_negation_, currentUnit)) {
                neg();
                tb();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void tb (void) {
	openXML(__func__);
	if (checkToken(FOIS)) {
		
                neg();
                tb();
		closeXML(__func__);
		return;
	}
	if (checkToken(DIVISE)) {
		
                neg();
                tb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_termeBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}

void neg (void) {
	openXML(__func__);
	if (checkToken(NON)) {
		
                neg();
		closeXML(__func__);
		return;
	}
	if (est_premier(_facteur_, currentUnit)) {
                f();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void f (void) {
	openXML(__func__);
	if (checkToken(PARENTHESE_OUVRANTE)) {
		
                exp();
		if (checkToken(PARENTHESE_FERMANTE)) {
			
			closeXML(__func__);
			return;
		}
	}
	if (checkToken(NOMBRE)) {
		
		closeXML(__func__);
		return;
	}
	if (checkToken(LIRE)) {
		
		if (checkToken(PARENTHESE_OUVRANTE)) {
			
			if (checkToken(PARENTHESE_FERMANTE)) {
				
				closeXML(__func__);
				return;
			}
		}
	}
	if (est_premier(_appelFct_, currentUnit)) {
                appf();
		closeXML(__func__);
		return;
	}
	if (est_premier(_var_, currentUnit)) {
                var();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void var (void) {
	openXML(__func__);
	if (checkToken(ID_VAR)) {
		
                oind();
		closeXML(__func__);
		return;
	}
	error();
	closeXML(__func__);
}

void oind (void) {
	openXML(__func__);
	if (checkToken(CROCHET_OUVRANT)) {
		
                exp();
		if (checkToken(CROCHET_FERMANT)) {
			
			closeXML(__func__);
			return;
		}
	}
	if (est_suivant(_optIndice_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}

void appf (void) {
	openXML(__func__);
	if (checkToken(ID_FCT)) {
		
		if (checkToken(PARENTHESE_OUVRANTE)) {
			
                        lexp();
			if (checkToken(PARENTHESE_FERMANTE)) {
				
				closeXML(__func__);
				return;
			}
		}
	}
	if (est_suivant(_appelFct_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}

void lexp (void) {
	openXML(__func__);
	if (est_premier(_expression_, currentUnit)) {
                exp();
                lexpb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_listeExpressions_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}

void lexpb (void) {
	openXML(__func__);
	if (checkToken(VIRGULE)) {
		
                exp();
                lexpb();
		closeXML(__func__);
		return;
	}
	if (est_suivant(_listeExpressionsBis_, currentUnit)) {
		closeXML(__func__);
		return;
	}
	error();	
	closeXML(__func__);
}


/**
 * Main function to use the synthaxic analyser.
 */
void analyse(void) {
	currentUnit = yylex();
	currentIndent = 0;
	
        pg();
	
	if (currentUnit != FIN) {
		error();
	}
	else {
		//printf("Lexical analyse succeded\n");
	}
}
